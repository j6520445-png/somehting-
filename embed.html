<!DOCTYPE html>
<html lang="en-us">
<head>
  <base href="https://j6520445-png.github.io/somehting-/">
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity WebGL Player | Hollow Knight (Web)</title>
  <link rel="shortcut icon" href="TemplateData/favicon.ico">
  <link rel="stylesheet" href="TemplateData/style.css">
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #231F20; }
    #unity-container { width: 100%; height: 100%; position: fixed; top: 0; left: 0; }
    /* Save/export/import overlay */
    #hk-save-controls {
      position: fixed; top: 10px; right: 10px; z-index: 10000; display: none;
      background: rgba(0,0,0,0.6); border-radius: 8px; padding: 6px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #hk-save-controls button {
      margin: 0 4px; padding: 6px 10px; font-size: 12px; color: #fff;
      background: #2d6cdf; border: 1px solid #1f4aa3; border-radius: 6px; cursor: pointer;
    }
    #hk-save-controls button:hover { filter: brightness(1.1); }
  </style>
</head>
<body>
  <div id="loading-text" style="color:#fff; font-size:48px; font-family:cursive; text-align:center; margin-top:20px;"> LOADING... </div>

  <!-- Export/Import controls (works entirely inside this page) -->
  <div id="hk-save-controls" title="Download or load your save">
    <button id="hk-export">Download Save</button>
    <button id="hk-import">Import Save</button>
    <button id="hk-newtab">Open in New Tab</button>
    <input id="hk-file" type="file" accept="application/json,.json" style="display:none" />
  </div>

  <div hidden id="unity-container" class="unity-desktop">
    <canvas id="unity-canvas"></canvas>
    <div id="unity-loading-bar">
      <div id="unity-logo"></div>
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
    </div>
    <div id="unity-mobile-warning"> WebGL builds are not supported on mobile devices. </div>
  </div>

  <script>
    // Persistent storage request (best-effort)
    (async () => { try { if (navigator.storage?.persist) await navigator.storage.persist(); } catch {} })();

    const loadingText = document.querySelector("#loading-text");
    let totalBytes = 0, loadedBytes = 0;
    let mbTotalLabel = '...';
    const MB = 1024 * 1024;

    async function getSize(url) {
      try {
        const res = await fetch(url, { method: "HEAD" });
        return parseInt(res.headers.get("Content-Length") || "0", 10);
      } catch { return 0; }
    }

    async function fetchWithProgress(url) {
      const response = await fetch(url);
      const reader = response.body.getReader();
      const chunks = [];
      let received = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        received += value.length;
        loadedBytes += value.length;
        chunks.push(value);
        const mbDone = (loadedBytes / MB).toFixed(2);
        loadingText.textContent = `LOADING... ${mbDone} MB / ${mbTotalLabel} MB`;
      }
      const fullBuffer = new Uint8Array(received);
      let offset = 0;
      for (const chunk of chunks) { fullBuffer.set(chunk, offset); offset += chunk.length; }
      return fullBuffer.buffer;
    }

    async function mergeFiles(fileParts) {
      const buffers = await Promise.all(fileParts.map(part => fetchWithProgress(part)));
      const mergedBlob = new Blob(buffers);
      return URL.createObjectURL(mergedBlob);
    }

    function getParts(file, start, end) {
      const parts = [];
      for (let i = start; i <= end; i++) parts.push(file + ".part" + i);
      return parts;
    }

    // ----- Persistent saves (IDBFS) + Export/Import helpers -----
    async function setupPersistentSaves(unityInstance) {
      const Module = unityInstance.Module;
      const FS = Module && Module.FS;
      if (!Module || !FS) return;

      // Mount IDBFS
      try {
        const idbfsPath = '/idbfs';
        const exists = FS.analyzePath(idbfsPath).exists;
        if (!exists) { FS.mkdir(idbfsPath); FS.mount(Module.IDBFS, {}, idbfsPath); }
      } catch {}

      // Initial sync from IndexedDB
      await new Promise(resolve => { try { FS.syncfs(true, () => resolve()); } catch { resolve(); } });

      // Mark FS ready for UI
      window.__hkModule = Module;
      window.__hkFSReady = true;

      // Periodic save
      const doSync = (done) => { try { FS.syncfs(false, () => done && done()); } catch { done && done(); } };
      const interval = setInterval(() => doSync(), 15000);

      // Lifecycle saves
      document.addEventListener('visibilitychange', () => { if (document.hidden) doSync(); });
      window.addEventListener('pagehide', () => doSync());
      window.addEventListener('beforeunload', () => doSync());

      // postMessage save hook
      window.addEventListener('message', (e) => { if (e?.data?.type === 'HK_SAVE') doSync(); });

      // Quit hook
      if (unityInstance.Quit) {
        const originalQuit = unityInstance.Quit.bind(unityInstance);
        unityInstance.Quit = () => new Promise((resolve, reject) => {
          clearInterval(interval); doSync(() => { originalQuit().then(resolve).catch(reject); });
        });
      }

      // Manual hook
      window.hollowKnightSaveNow = () => doSync();
    }

    function hkEnsureDirs(FS, fullPath) {
      const parts = fullPath.split('/');
      let current = '';
      for (let i = 1; i < parts.length - 1; i++) {
        current += '/' + parts[i];
        try { if (!FS.analyzePath(current).exists) FS.mkdir(current); } catch { try { FS.mkdir(current); } catch {} }
      }
    }
    function hkListFilesRecursive(FS, root) {
      const files = [];
      const walk = (p) => {
        let entries; try { entries = FS.readdir(p); } catch { return; }
        for (const name of entries) {
          if (name === '.' || name === '..') continue;
          const full = p === '/' ? '/' + name : p + '/' + name;
          try {
            const st = FS.stat(full);
            if (FS.isDir(st.mode)) walk(full); else files.push(full);
          } catch {}
        }
      };
      walk(root); return files;
    }
    function hkUint8ToBase64(u8) {
      const CHUNK = 0x8000; let result = '';
      for (let i = 0; i < u8.length; i += CHUNK) result += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
      return btoa(result);
    }
    function hkBase64ToUint8(b64) {
      const str = atob(b64); const u8 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) u8[i] = str.charCodeAt(i);
      return u8;
    }
    async function hkExportSave() {
      try {
        if (!window.__hkModule || !window.__hkFSReady) return alert('Save system not ready yet. Try again shortly.');
        const { FS } = window.__hkModule;
        await new Promise(r => { try { FS.syncfs(false, () => r()); } catch { r(); } });
        const files = hkListFilesRecursive(FS, '/idbfs');
        const payload = { version: 1, createdAt: new Date().toISOString(), files: [] };
        for (const path of files) {
          try { const data = FS.readFile(path, { encoding: 'binary' }); payload.files.push({ path, b64: hkUint8ToBase64(data) }); } catch {}
        }
        const blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `hk-save-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        document.body.appendChild(a); a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
      } catch (e) { alert('Export failed: ' + (e?.message || e)); }
    }
    async function hkImportSave(file) {
      try {
        if (!window.__hkModule || !window.__hkFSReady) return alert('Save system not ready yet. Try again shortly.');
        const text = await file.text(); const data = JSON.parse(text);
        if (!data || !Array.isArray(data.files)) return alert('Invalid save file.');
        const { FS } = window.__hkModule;
        for (const f of data.files) {
          if (!f?.path || !f?.b64) continue;
          try { hkEnsureDirs(FS, f.path); FS.writeFile(f.path, hkBase64ToUint8(f.b64), { encoding: 'binary' }); } catch {}
        }
        await new Promise(r => { try { FS.syncfs(false, () => r()); } catch { r(); } });
        alert('Save imported. If needed, return to main menu or reload to apply.');
      } catch (e) { alert('Import failed: ' + (e?.message || e)); }
    }
    // ----- End persistence helpers -----

    (async () => {
      const allParts = [
        ...getParts("Build/bog.data", 1, 44),
        ...getParts("Build/bog.wasm", 1, 2),
      ];
      const sizes = await Promise.all(allParts.map(getSize));
      totalBytes = sizes.reduce((a, b) => a + b, 0);
      mbTotalLabel = (totalBytes / MB).toFixed(2);

      const [dataUrl, wasmurl] = await Promise.all([
        mergeFiles(getParts("Build/bog.data", 1, 44)),
        mergeFiles(getParts("Build/bog.wasm", 1, 2)),
      ]);

      const buildUrl = "Build";
      const loaderUrl = buildUrl + "/bog.loader.js";
      const config = {
        dataUrl: dataUrl,
        frameworkUrl: buildUrl + "/bog.framework.js",
        codeUrl: wasmurl,
        streamingAssetsUrl: "StreamingAssets",
        companyName: "Team Cherry & Truffled",
        productName: "Hollow Knight",
        productVersion: "1.0",
      };

      const container = document.querySelector("#unity-container");
      const canvas = document.querySelector("#unity-canvas");
      const loadingBar = document.querySelector("#unity-loading-bar");
      const progressBarFull = document.querySelector("#unity-progress-bar-full");
      const mobileWarning = document.querySelector("#unity-mobile-warning");

      container.hidden = false;

      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      if (isMobile) {
        container.className = "unity-mobile";
        config.devicePixelRatio = 1;
        mobileWarning.style.display = "block";
        setTimeout(() => { mobileWarning.style.display = "none"; }, 5000);
        const meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.head.appendChild(meta);
      } else {
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          canvas.style.width = window.innerWidth + "px";
          canvas.style.height = window.innerHeight + "px";
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
      }

      loadingBar.style.display = "block";
      const script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = (100 * progress) + "%";
        }).then((unityInstance) => {
          loadingText.remove();
          loadingBar.style.display = "none";
          canvas.style.display = "block";

          // Persistence + Save UI
          setupPersistentSaves(unityInstance);
          const controls = document.getElementById('hk-save-controls');
          const btnExport = document.getElementById('hk-export');
          const btnImport = document.getElementById('hk-import');
          const btnNewTab = document.getElementById('hk-newtab');
          const fileInput = document.getElementById('hk-file');
          controls.style.display = 'block';
          btnExport.addEventListener('click', () => hkExportSave());
          btnImport.addEventListener('click', () => fileInput.click());
          fileInput.addEventListener('change', (e) => {
            const f = e.target.files && e.target.files[0];
            if (f) hkImportSave(f);
            e.target.value = '';
          });

          // Open in about:blank first, then redirect (bypasses iframe URL restrictions more often)
          btnNewTab.addEventListener('click', () => {
            const targetUrl = 'https://j6520445-png.github.io/somehting-/index.html';
            const w = window.open('about:blank', '_blank');
            if (!w) { alert('Popup blocked by the browser. Allow popups for this site.'); return; }
            try {
              w.document.write(`<!doctype html><html><head><title>Loading…</title><meta http-equiv="refresh" content="0;url=${targetUrl}"></head><body style="background:#111;color:#fff;font-family:sans-serif;display:flex;align-items:center;justify-content:center;height:100vh;">Opening game…</body></html>`);
              w.document.close();
            } catch {
              try { w.location.href = targetUrl; } catch {}
            }
          });

        }).catch((message) => { alert(message); });
      };
      document.body.appendChild(script);
    })();
  </script>
</body>
</html>