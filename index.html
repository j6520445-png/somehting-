<!DOCTYPE html>
<html lang="en-us">
<head>
  <base href="https://j6520445-png.github.io/somehting-/">
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Unity WebGL Player | Hollow Knight (Web)</title>
  <link rel="shortcut icon" href="TemplateData/favicon.ico">
  <link rel="stylesheet" href="TemplateData/style.css">
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #231F20; }
    #unity-container { width: 100%; height: 100%; position: fixed; top: 0; left: 0; }
    #unity-canvas { position: relative; z-index: 1; }
    /* Simple overlay for Save/Load controls */
    #save-load-bar {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 9999;
      display: flex;
      gap: 8px;
      align-items: center;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 8px 10px;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      backdrop-filter: blur(4px);
    }
    #save-load-bar button {
      background: #2e7d32;
      color: #fff;
      border: none;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }
    #save-load-bar button.load { background: #1565c0; }
    #save-load-bar .note { opacity: 0.75; font-size: 12px; }
  </style>
</head>
<body>
  <!-- Save/Load controls overlay (non-invasive) -->
  <div id="save-load-bar" title="Export/import a save file. Press H to hide/show this bar.">
    <button id="btn-save" aria-label="Trigger in-game save and download JSON">Save JSON</button>
    <button id="btn-load" class="load" aria-label="Load JSON into the game">Load JSON</button>
    <span class="note">Simple JSON Save/Load via Unity</span>
    <details style="margin-left:8px;">
      <summary style="cursor:pointer;">Settings</summary>
      <div style="display:flex; gap:6px; align-items:center; margin-top:6px;">
        <label>Object <input id="ub-obj" style="width:120px;" value="GameManager" /></label>
        <label>Save <input id="ub-save" style="width:120px;" value="SaveGame" /></label>
        <label>Load <input id="ub-load" style="width:160px;" value="LoadGameFromJSON" /></label>
        <button id="ub-apply" style="background:#555;">Apply</button>
      </div>
    </details>
    <button id="btn-save-ready" style="display:none; background:#8e24aa;">Download Ready</button>
    <span id="save-status" class="note" style="margin-left:6px;"></span>
  </div>
  <div id="loading-text" style="color:#fff; font-size:48px; font-family:cursive; text-align:center; margin-top:20px;"> LOADING... </div>
  <div hidden id="unity-container" class="unity-desktop">
    <canvas id="unity-canvas"></canvas>
    <div id="unity-loading-bar">
      <div id="unity-logo"></div>
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
    </div>
    <div id="unity-mobile-warning"> WebGL builds are not supported on mobile devices. </div>
  </div>

  <script>
    // Register service worker for offline/PWA install
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(() => {});
      });
    }

  const loadingText = document.querySelector('#loading-text');
  // Unity bridge defaults â€” update if your GameObject or method names differ; persisted in localStorage
  const unityBridge = { gameObject: 'GameManager', saveMethod: 'SaveGame', loadMethod: 'LoadGameFromJSON' };
  try {
    const savedBridge = JSON.parse(localStorage.getItem('hk_unity_bridge') || 'null');
    if (savedBridge && savedBridge.gameObject && savedBridge.saveMethod && savedBridge.loadMethod) {
      unityBridge.gameObject = savedBridge.gameObject;
      unityBridge.saveMethod = savedBridge.saveMethod;
      unityBridge.loadMethod = savedBridge.loadMethod;
    }
  } catch {}
  const SAVE_KEY = 'hollow_knight_save_data';
  // Keep the most recent JSON the user loaded, so we can re-download the exact same content if needed
  let HK_LAST_LOADED_JSON = null;
    let totalBytes = 0, loadedBytes = 0;
    let mbTotalLabel = '...';
    const MB = 1024 * 1024;

    async function getSize(url) {
      try {
        const res = await fetch(url, { method: 'HEAD' });
        return parseInt(res.headers.get('Content-Length') || '0', 10);
      } catch { return 0; }
    }

    async function fetchWithProgress(url) {
      const response = await fetch(url);
      const reader = response.body.getReader();
      const chunks = [];
      let received = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        received += value.length;
        loadedBytes += value.length;
        chunks.push(value);
        const mbDone = (loadedBytes / MB).toFixed(2);
        if (loadingText) loadingText.textContent = `LOADING... ${mbDone} MB / ${mbTotalLabel} MB`;
      }
      const fullBuffer = new Uint8Array(received);
      let offset = 0;
      for (const chunk of chunks) { fullBuffer.set(chunk, offset); offset += chunk.length; }
      return fullBuffer.buffer;
    }

    async function mergeFiles(fileParts) {
      const buffers = await Promise.all(fileParts.map(part => fetchWithProgress(part)));
      const mergedBlob = new Blob(buffers);
      return URL.createObjectURL(mergedBlob);
    }

    function getParts(file, start, end) {
      const parts = [];
      for (let i = start; i <= end; i++) parts.push(file + '.part' + i);
      return parts;
    }

    // Helper: Uint8Array -> base64
    function hkUint8ToBase64(u8) {
      const CHUNK = 0x8000; let result = '';
      for (let i = 0; i < u8.length; i += CHUNK) {
        result += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
      }
      return btoa(result);
    }
    // Helper: base64 -> Uint8Array
    function hkBase64ToUint8(b64) {
      const str = atob(b64); const u8 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) u8[i] = str.charCodeAt(i);
      return u8;
    }
    // Helper: arrayBuffer -> base64
    function hkArrayBufferToBase64(buf) {
      const u8 = new Uint8Array(buf);
      return hkUint8ToBase64(u8);
    }
    // Helper: CRC32 for integrity metadata
    function hkCrc32(str) {
      let c; const table = hkCrc32.table || (hkCrc32.table = (() => {
        const t = []; for (let n = 0; n < 256; n++) { c = n; for (let k = 0; k < 8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1)); t[n] = c >>> 0; } return t; })());
      let crc = 0 ^ (-1);
      for (let i = 0; i < str.length; i++) crc = (crc >>> 8) ^ table[(crc ^ str.charCodeAt(i)) & 0xFF];
      return ((crc ^ (-1)) >>> 0).toString(16);
    }
    function hkPayload(dataObj) {
      const dataStr = JSON.stringify(dataObj);
      return { meta: { version: '1.0', savedAt: Date.now(), checksumHex: hkCrc32(dataStr) }, data: dataObj };
    }

    // --- Browser storage exporters ---
    function exportLocalStorage() {
      const out = {};
      try {
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i);
          out[k] = localStorage.getItem(k);
        }
      } catch {}
      return out;
    }

    function readAllFromStore(store) {
      return new Promise((resolve) => {
        const items = [];
        if (store.getAll && store.getAllKeys) {
          const reqVals = store.getAll();
          const reqKeys = store.getAllKeys();
          let vals=null, keys=null;
          reqVals.onsuccess = () => { vals = reqVals.result; if (keys!==null) finish(); };
          reqKeys.onsuccess = () => { keys = reqKeys.result; if (vals!==null) finish(); };
          reqVals.onerror = reqKeys.onerror = () => resolve(items);
          function finish() {
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = vals[i];
              items.push({ key, value });
            }
            resolve(items);
          }
        } else {
          const cursor = store.openCursor();
          cursor.onsuccess = (e) => {
            const cur = e.target.result;
            if (cur) { items.push({ key: cur.key, value: cur.value }); cur.continue(); }
            else resolve(items);
          };
          cursor.onerror = () => resolve(items);
        }
      });
    }

    function deepSanitizeIDBValue(v, depth = 0) {
      try {
        if (depth > 5) return v; // avoid very deep recursion
        if (v instanceof ArrayBuffer) {
          return { __type: 'base64', data: hkArrayBufferToBase64(v) };
        }
        if (ArrayBuffer.isView && ArrayBuffer.isView(v)) {
          return { __type: 'base64', data: hkUint8ToBase64(new Uint8Array(v.buffer)) };
        }
        if (v && typeof v === 'object') {
          if (v.contents instanceof ArrayBuffer) {
            return { ...v, contents: { __type: 'base64', data: hkArrayBufferToBase64(v.contents) } };
          }
          if (Array.isArray(v)) {
            return v.map(item => deepSanitizeIDBValue(item, depth + 1));
          }
          const out = {};
          for (const [k, val] of Object.entries(v)) out[k] = deepSanitizeIDBValue(val, depth + 1);
          return out;
        }
      } catch {}
      return v;
    }

    async function exportIndexedDB_IDBFS_FILE_DATA() {
      // Emscripten IDBFS: DB name 'IDBFS', store 'FILE_DATA'
      return new Promise((resolve) => {
        const out = { ok: false };
        const req = indexedDB.open('IDBFS');
        req.onsuccess = async () => {
          const db = req.result;
          try {
            const tx = db.transaction('FILE_DATA', 'readonly');
            const store = tx.objectStore('FILE_DATA');
            const items = await readAllFromStore(store);
            out.ok = true;
            out.items = items.map(({key, value}) => ({ key, value: deepSanitizeIDBValue(value) }));
          } catch {}
          try { db.close(); } catch{}
          resolve(out);
        };
        req.onerror = () => resolve(out);
      });
    }

    async function exportAllIndexedDB() {
      const result = {};
      try {
        if (indexedDB.databases) {
          const dbs = await indexedDB.databases();
          for (const info of dbs) {
            const name = info.name;
            if (!name) continue;
            result[name] = {};
            await new Promise((resolveDb) => {
              const req = indexedDB.open(name);
              req.onsuccess = async () => {
                const db = req.result;
                try {
                  const stores = Array.from(db.objectStoreNames || []);
                  for (const storeName of stores) {
                    try {
                      const tx = db.transaction(storeName, 'readonly');
                      const store = tx.objectStore(storeName);
                      const items = await readAllFromStore(store);
                      result[name][storeName] = items.map(({key, value}) => ({ key, value: deepSanitizeIDBValue(value) }));
                    } catch {}
                  }
                } catch {}
                try { db.close(); } catch {}
                resolveDb();
              };
              req.onerror = () => resolveDb();
            });
          }
        }
      } catch {}
      return result;
    }

    async function buildBrowserSavePayload() {
      const dataObj = { storage: { localStorage: exportLocalStorage() } };
      // Try common Emscripten IDBFS DB
      try {
        const idbfsDump = await exportIndexedDB_IDBFS_FILE_DATA();
        if (idbfsDump && idbfsDump.ok) {
          dataObj.storage.indexedDB = dataObj.storage.indexedDB || {};
          dataObj.storage.indexedDB.IDBFS = { FILE_DATA: idbfsDump.items };
        }
      } catch {}
      // Dump all IndexedDB databases/stores (if supported)
      try {
        const all = await exportAllIndexedDB();
        if (all && Object.keys(all).length) {
          dataObj.storage.indexedDBGeneric = all;
        }
      } catch {}
      // If FS is available, add file-level snapshot too (may duplicate IDB but useful)
      try {
        const unity = window.unityInstance; const Module = unity && unity.Module; const FS = Module && Module.FS;
        if (Module && FS) {
          if (Module.IDBFS) {
            try { if (!FS.analyzePath('/idbfs').exists) { FS.mkdir('/idbfs'); FS.mount(Module.IDBFS, {}, '/idbfs'); } } catch {}
            await new Promise(r => { try { FS.syncfs(true, () => r()); } catch { r(); } });
          }
          const roots = ['/idbfs', '/persistent', '/saves', '/userdata'];
          const files = [];
          for (const root of roots) {
            try {
              if (!FS.analyzePath(root).exists) continue;
              const list = FS.readdir(root).filter(f => f !== '.' && f !== '..');
              for (const name of list) {
                const full = `${root}/${name}`;
                try {
                  const st = FS.stat(full);
                  if (!FS.isDir(st.mode)) {
                    const bytes = FS.readFile(full);
                    files.push({ path: full, b64: hkUint8ToBase64(bytes) });
                  }
                } catch {}
              }
            } catch {}
          }
          dataObj.fsSnapshot = { files };
        }
      } catch {}
      return hkPayload(dataObj);
    }

    // --- Importers (reverse of the above) ---
    function deepReviveIDBValue(v, depth = 0) {
      if (depth > 5) return v;
      try {
        if (v && typeof v === 'object' && v.__type === 'base64' && typeof v.data === 'string') {
          return hkBase64ToUint8(v.data).buffer;
        }
        if (v && typeof v === 'object' && v.contents && v.contents.__type === 'base64') {
          return { ...v, contents: hkBase64ToUint8(v.contents.data).buffer };
        }
        if (Array.isArray(v)) return v.map(x => deepReviveIDBValue(x, depth + 1));
        if (v && typeof v === 'object') {
          const out = {};
          for (const [k, val] of Object.entries(v)) out[k] = deepReviveIDBValue(val, depth + 1);
          return out;
        }
      } catch {}
      return v;
    }

    function restoreLocalStorage(lsObj) {
      if (!lsObj || typeof lsObj !== 'object') return;
      try {
        for (const [k, v] of Object.entries(lsObj)) {
          try { localStorage.setItem(k, String(v)); } catch {}
        }
      } catch {}
    }

    function restoreIndexedDBFileData(items) {
      return new Promise((resolve) => {
        if (!Array.isArray(items) || items.length === 0) { resolve(true); return; }
        const req = indexedDB.open('IDBFS');
        req.onsuccess = () => {
          const db = req.result;
          let tx; try { tx = db.transaction('FILE_DATA', 'readwrite'); } catch { try { db.close(); } catch{}; resolve(false); return; }
          const store = tx.objectStore('FILE_DATA');
          let remaining = items.length; if (remaining === 0) { try { db.close(); } catch{}; resolve(true); return; }
          items.forEach(({key, value}) => {
            const revived = deepReviveIDBValue(value);
            const putReq = store.put(revived, key);
            putReq.onsuccess = () => { if (--remaining === 0) { try { db.close(); } catch{}; resolve(true); } };
            putReq.onerror = () => { if (--remaining === 0) { try { db.close(); } catch{}; resolve(false); } };
          });
        };
        req.onerror = () => resolve(false);
      });
    }

    function restoreIndexedDBGeneric(allDbs) {
      return new Promise(async (resolve) => {
        if (!allDbs || typeof allDbs !== 'object') { resolve(true); return; }
        const dbNames = Object.keys(allDbs);
        for (const dbName of dbNames) {
          const stores = allDbs[dbName];
          if (!stores || typeof stores !== 'object') continue;
          await new Promise((resolveDb) => {
            const req = indexedDB.open(dbName);
            req.onsuccess = async () => {
              const db = req.result;
              try {
                for (const storeName of Object.keys(stores)) {
                  try {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    const items = stores[storeName];
                    await new Promise((resolveStore) => {
                      let remaining = items.length;
                      if (remaining === 0) { resolveStore(); return; }
                      items.forEach(({key, value}) => {
                        const revived = deepReviveIDBValue(value);
                        const putReq = store.put(revived, key);
                        const done = () => { if (--remaining === 0) resolveStore(); };
                        putReq.onsuccess = done; putReq.onerror = done;
                      });
                    });
                  } catch {}
                }
              } catch {}
              try { db.close(); } catch {}
              resolveDb();
            };
            req.onerror = () => resolveDb();
          });
        }
        resolve(true);
      });
    }

    async function restoreFSSnapshot(fsSnapshot) {
      try {
        if (!fsSnapshot || !Array.isArray(fsSnapshot.files)) return true;
        const unity = window.unityInstance; const Module = unity && unity.Module; const FS = Module && Module.FS;
        if (!(Module && FS)) return false;
        if (Module.IDBFS) {
          try { if (!FS.analyzePath('/idbfs').exists) { FS.mkdir('/idbfs'); FS.mount(Module.IDBFS, {}, '/idbfs'); } } catch {}
          await new Promise(r => { try { FS.syncfs(true, () => r()); } catch { r(); } });
        }
        for (const f of fsSnapshot.files) {
          try { hkEnsureDirs(FS, f.path); FS.writeFile(f.path, hkBase64ToUint8(f.b64)); } catch {}
        }
        try { await new Promise(r => { try { FS.syncfs(false, () => r()); } catch { r(); } }); } catch {}
        return true;
      } catch { return false; }
    }

    async function importBrowserSavePayload(parsedPayload, onStatus) {
      const payload = parsedPayload && parsedPayload.meta && parsedPayload.data ? parsedPayload.data : parsedPayload;
      if (!payload || typeof payload !== 'object') throw new Error('Invalid save payload');
      try { onStatus && onStatus('Restoring localStorage...'); } catch {}
      if (payload.storage && payload.storage.localStorage) restoreLocalStorage(payload.storage.localStorage);
      if (payload.storage && payload.storage.indexedDB && payload.storage.indexedDB.IDBFS && Array.isArray(payload.storage.indexedDB.IDBFS.FILE_DATA)) {
        try { onStatus && onStatus('Restoring IDBFS...'); } catch {}
        await restoreIndexedDBFileData(payload.storage.indexedDB.IDBFS.FILE_DATA);
      }
      if (payload.storage && payload.storage.indexedDBGeneric) {
        try { onStatus && onStatus('Restoring IndexedDB databases...'); } catch {}
        await restoreIndexedDBGeneric(payload.storage.indexedDBGeneric);
      }
      if (payload.fsSnapshot) {
        try { onStatus && onStatus('Restoring files...'); } catch {}
        await restoreFSSnapshot(payload.fsSnapshot);
      }
      return true;
    }
    // Ensure directory path exists in Emscripten FS
    function hkEnsureDirs(FS, fullPath) {
      const parts = fullPath.split('/');
      let current = '';
      for (let i = 1; i < parts.length - 1; i++) {
        current += '/' + parts[i];
        try { if (!FS.analyzePath(current).exists) FS.mkdir(current); } catch { try { FS.mkdir(current); } catch {} }
      }
    }

    // Single backup tick: captures FS (if available) into localStorage
    function hkPerformBackup(unityInstance) {
      try {
        const Module = unityInstance && unityInstance.Module;
        if (Module && Module.FS) {
          const savePaths = [ '/idbfs', '/persistent', '/saves', '/userdata' ];
          const saveData = { timestamp: Date.now(), version: '1.0' };
          for (const path of savePaths) {
            try {
              if (Module.FS.analyzePath(path).exists) {
                const files = Module.FS.readdir(path);
                saveData[path] = files.filter(f => f !== '.' && f !== '..');
                for (const file of saveData[path]) {
                  try {
                    const fullPath = path + '/' + file;
                    const stats = Module.FS.stat(fullPath);
                    if (!Module.FS.isDir(stats.mode)) {
                      const bytes = Module.FS.readFile(fullPath);
                      saveData[fullPath] = hkUint8ToBase64(bytes);
                    }
                  } catch {}
                }
              }
            } catch {}
          }
          localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
        } else {
          // Fallback heartbeat so we at least track sessions
          const prev = JSON.parse(localStorage.getItem(SAVE_KEY) || '{}');
          const stub = { timestamp: Date.now(), sessions: (prev.sessions || 0) + 1, fallback_mode: true };
          localStorage.setItem(SAVE_KEY, JSON.stringify(stub));
        }
      } catch (e) { console.log('Backup tick failed:', e); }
    }

    // Universal autosave loop: starts immediately and runs regardless of init order
    function startUniversalAutosave() {
      if (window.__hkBackupInterval) return; // guard against duplicates
      window.__hkBackupInterval = setInterval(() => {
        hkPerformBackup(window.unityInstance || null);
      }, 15000);
      // Also perform an initial quick backup shortly after page load
      setTimeout(() => hkPerformBackup(window.unityInstance || null), 3000);
    }

    // Restore-on-start and mount IDBFS when Unity is ready
    async function setupLocalStorageSaves(unityInstance) {
      let saveInterval; // deprecated by universal loop, kept for compatibility
      try {
        // Try to restore previous save when game starts
        const savedData = localStorage.getItem(SAVE_KEY);
        if (savedData) {
          console.log('Found previous save data, attempting restore');
          try {
            const Module = unityInstance.Module;
            const FS = Module && Module.FS;
            const data = JSON.parse(savedData);
            if (Module && FS && data) {
              // Mount IDBFS if available so writes persist
              if (Module.IDBFS) {
                try { if (!FS.analyzePath('/idbfs').exists) { FS.mkdir('/idbfs'); FS.mount(Module.IDBFS, {}, '/idbfs'); } } catch {}
                await new Promise(r => { try { FS.syncfs(true, () => r()); } catch { r(); } });
              }
              // Write back any file entries saved as absolute paths
              for (const [key, val] of Object.entries(data)) {
                if (typeof key === 'string' && key.startsWith('/') && typeof val === 'string') {
                  try {
                    hkEnsureDirs(FS, key);
                    FS.writeFile(key, hkBase64ToUint8(val));
                  } catch {}
                }
              }
              try { await new Promise(r => { try { FS.syncfs(false, () => r()); } catch { r(); } }); } catch {}
              console.log('Restore complete');
            }
          } catch (e) { console.log('Restore failed:', e); }
        }

        // Universal loop is already running; avoid setting another interval
        if (!window.__hkBackupInterval) {
          window.__hkBackupInterval = setInterval(() => hkPerformBackup(unityInstance), 15000);
        }

        const emergencySave = () => {
          if (saveInterval) clearInterval(saveInterval);
          try {
            const saveData = JSON.parse(localStorage.getItem(SAVE_KEY) || '{}');
            saveData.lastExit = Date.now();
            saveData.emergencyExit = true;
            localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
          } catch {}
        };
        window.addEventListener('beforeunload', emergencySave);
        window.addEventListener('pagehide', emergencySave);
        document.addEventListener('visibilitychange', () => { if (document.hidden) emergencySave(); });
        console.log('localStorage save system initialized - saves every 15 seconds');
      } catch (e) { console.log('localStorage save system failed to initialize:', e); }
    }

    (async () => {
      const allParts = [ ...getParts('Build/bog.data', 1, 44), ...getParts('Build/bog.wasm', 1, 2) ];
      const sizes = await Promise.all(allParts.map(getSize));
      totalBytes = sizes.reduce((a, b) => a + b, 0);
      mbTotalLabel = (totalBytes / MB).toFixed(2);

      const [dataUrl, wasmurl] = await Promise.all([
        mergeFiles(getParts('Build/bog.data', 1, 44)),
        mergeFiles(getParts('Build/bog.wasm', 1, 2)),
      ]);

      const buildUrl = 'Build';
      const loaderUrl = buildUrl + '/bog.loader.js';
      const config = {
        dataUrl: dataUrl,
        frameworkUrl: buildUrl + '/bog.framework.js',
        codeUrl: wasmurl,
        streamingAssetsUrl: 'StreamingAssets',
        companyName: 'Team Cherry & Truffled',
        productName: 'Hollow Knight',
        productVersion: '1.0',
      };

      const container = document.querySelector('#unity-container');
      const canvas = document.querySelector('#unity-canvas');
      const loadingBar = document.querySelector('#unity-loading-bar');
      const progressBarFull = document.querySelector('#unity-progress-bar-full');
      const mobileWarning = document.querySelector('#unity-mobile-warning');

      container.hidden = false;

      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      if (isMobile) {
        container.className = 'unity-mobile';
        config.devicePixelRatio = 1;
        mobileWarning.style.display = 'block';
        setTimeout(() => { mobileWarning.style.display = 'none'; }, 5000);
        const meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.head.appendChild(meta);
      } else {
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          canvas.style.width = window.innerWidth + 'px';
          canvas.style.height = window.innerHeight + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
      }

      loadingBar.style.display = 'block';
      const script = document.createElement('script');
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = 100 * progress + '%';
        }).then((unityInstance) => {
          // Expose for Save/Load helpers and remove loading text
          window.unityInstance = unityInstance;
          try { loadingText.remove(); } catch {}
          loadingBar.style.display = 'none';
          // Optional fullscreen via 'F' key
          window.addEventListener('keydown', (e) => { if ((e.key || '').toLowerCase() === 'f') unityInstance.SetFullscreen(1); });
          // Note: autosave/backup disabled per user request
        }).catch((message) => { alert(message); });
      };
      document.body.appendChild(script);
    })();

    // Autosave/backup disabled

    // --- Lightweight Save/Load helpers matching the requested behavior ---
    function downloadFile(filename, text) {
      try {
        const blob = new Blob([text], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        // Give the browser time to finish the download before revoking
        setTimeout(() => URL.revokeObjectURL(link.href), 15000);
      } catch (e) {
        console.error('Download failed:', e);
        alert('Failed to download save file.');
      }
    }

    function uploadFile(onJson) {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json,application/json';
      input.onchange = (ev) => {
        const file = ev.target.files && ev.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try { onJson(String(e.target.result)); }
          catch (err) { console.error('Error reading file:', err); alert('Failed to read the selected file.'); }
        };
        reader.readAsText(file);
      };
      input.click();
    }

    // Simple JSON Save/Load via Unity SendMessage
    async function saveJsonViaUnity() {
      const statusEl = document.getElementById('save-status');
      const saveBtn = document.getElementById('btn-save');
      const readyBtn = document.getElementById('btn-save-ready');
      // 1) Try to nudge Unity to save (if their build supports a download)
      try { if (window.unityInstance && typeof window.unityInstance.SendMessage === 'function') {
        window.unityInstance.SendMessage(unityBridge.gameObject, unityBridge.saveMethod, '');
      }} catch (e) { console.warn('Unity save call failed:', e); }

      // 2) Always produce a real file download as fallback so you never get placeholders
      // Prefer the most recent JSON that the user loaded (round-trip fidelity)
      if (HK_LAST_LOADED_JSON) {
        try {
          const parsed = JSON.parse(HK_LAST_LOADED_JSON);
          const payload = hkPayload(parsed);
          const ts = new Date().toISOString().replace(/[:.]/g,'-');
          downloadFile(`HK_Save_${ts}.json`, JSON.stringify(payload));
          return;
        } catch {}
      }

      // 3) Build a browser-side save payload (localStorage + IndexedDB FILE_DATA + FS snapshot if available)
      // Prepare asynchronously, then show a Download Ready button to satisfy browser gesture rules
      if (statusEl) statusEl.textContent = 'Preparing save...';
      if (saveBtn) { saveBtn.disabled = true; saveBtn.textContent = 'Preparing...'; }
      try {
          const payload = await buildBrowserSavePayload();
          const ts = new Date().toISOString().replace(/[:.]/g,'-');
          window.__hkPreparedSaveString = JSON.stringify(payload);
          window.__hkPreparedSaveName = `HK_Save_${ts}.json`;
          if (statusEl) statusEl.textContent = 'Save ready.';
          if (readyBtn) { readyBtn.style.display = 'inline-block'; }
          return;
      } catch (e) { console.warn('FS snapshot failed:', e); }

      if (statusEl) statusEl.textContent = 'Could not prepare save payload.';
      if (saveBtn) { saveBtn.disabled = false; saveBtn.textContent = 'Save JSON'; }
    }

    function loadJsonIntoUnity() {
      uploadFile(async (json) => {
        if (!window.unityInstance || typeof window.unityInstance.SendMessage !== 'function') {
          // Even if Unity isn't ready, we can still import browser storage and then reload
        }
        // Remember the exact JSON for reliable re-downloads later
        HK_LAST_LOADED_JSON = json;
        // Try to detect browser-storage payload and restore it
        const statusEl = document.getElementById('save-status');
        try {
          const parsed = JSON.parse(json);
          const dataPart = parsed && parsed.meta && parsed.data ? parsed.data : parsed;
          const looksLikeBrowserDump = dataPart && (dataPart.storage || dataPart.fsSnapshot);
          if (looksLikeBrowserDump) {
            if (statusEl) statusEl.textContent = 'Importing...';
            await importBrowserSavePayload(parsed, (msg) => { if (statusEl) statusEl.textContent = msg; });
            if (statusEl) statusEl.textContent = 'Imported. Reloading...';
            setTimeout(() => location.reload(), 800);
            return;
          }
        } catch {}

        // Fallback: pass JSON to Unity method if available
        if (window.unityInstance && typeof window.unityInstance.SendMessage === 'function') {
          try {
            window.unityInstance.SendMessage(unityBridge.gameObject, unityBridge.loadMethod, json);
            alert('Save data sent to the game. If nothing changes, verify the GameObject and method names.');
          } catch (e) {
            console.error(e);
            alert(`Could not call ${unityBridge.gameObject}.${unityBridge.loadMethod}(json). Make sure the method exists in the build.`);
          }
        } else {
          alert('Imported save stored. Reloading the page may be required.');
        }
      });
    }

    // Wire up UI and toggle
    const btnSave = document.getElementById('btn-save');
    const btnLoad = document.getElementById('btn-load');
  btnSave && btnSave.addEventListener('click', saveJsonViaUnity);
  btnLoad && btnLoad.addEventListener('click', loadJsonIntoUnity);
    const bar = document.getElementById('save-load-bar');
    const btnSaveReady = document.getElementById('btn-save-ready');
    const statusEl = document.getElementById('save-status');
    btnSaveReady && btnSaveReady.addEventListener('click', () => {
      if (window.__hkPreparedSaveString && window.__hkPreparedSaveName) {
        downloadFile(window.__hkPreparedSaveName, window.__hkPreparedSaveString);
        // reset UI
        btnSaveReady.style.display = 'none';
        if (statusEl) statusEl.textContent = 'Downloaded.';
        const saveBtn = document.getElementById('btn-save');
        if (saveBtn) { saveBtn.disabled = false; saveBtn.textContent = 'Save JSON'; }
        window.__hkPreparedSaveString = null;
        window.__hkPreparedSaveName = null;
      }
    });
    // Bridge settings UI
    const ubObj = document.getElementById('ub-obj');
    const ubSave = document.getElementById('ub-save');
    const ubLoad = document.getElementById('ub-load');
    const ubApply = document.getElementById('ub-apply');
    if (ubObj && ubSave && ubLoad) {
      ubObj.value = unityBridge.gameObject;
      ubSave.value = unityBridge.saveMethod;
      ubLoad.value = unityBridge.loadMethod;
    }
    ubApply && ubApply.addEventListener('click', () => {
      unityBridge.gameObject = ubObj.value.trim() || unityBridge.gameObject;
      unityBridge.saveMethod = ubSave.value.trim() || unityBridge.saveMethod;
      unityBridge.loadMethod = ubLoad.value.trim() || unityBridge.loadMethod;
      try { localStorage.setItem('hk_unity_bridge', JSON.stringify(unityBridge)); } catch {}
      alert('Updated. Try Save/Load again.');
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'h' || e.key === 'H') {
        bar.style.display = (bar.style.display === 'none') ? 'flex' : 'none';
      }
    });
  </script>
</body>
</html>